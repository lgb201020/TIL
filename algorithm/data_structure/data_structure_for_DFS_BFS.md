# DFS/BFS를 위한 기본 자료 구조
## 스택(Stack) 자료구조
- 먼저 들어 온 데이터가 나중에 나가는 형식으로 동작하는 자료구조이다. (선입후출)
- 데이터의 입출력 구멍이 1개로 입력과 출력에서 동일한 구멍을 사용한다고 생각하면 된다.
- **입구와 출구가 동일한 형태**로 스택을 시각화 할 수 있다.

    ![stack_1](./img/stack_1.png)

### 스택 동작 예시
- 스택은 삽입과 삭제 두 연산으로 구성된다.
- **삽입(5)** - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![stack_2](./img/stack_2.png)

- **삽입(5) - 삽입(2)** - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![stack_3](./img/stack_3.png)

- **삽입(5) - 삽입(2) - 삽입(3)** - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![stack_4](./img/stack_4.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7)** - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![stack_5](./img/stack_5.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제()** - 삽입(1) - 삽입(4) - 삭제()
    ![stack_6](./img/stack_6.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1)** - 삽입(4) - 삭제()
    ![stack_7](./img/stack_7.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4)** - 삭제()
    ![stack_8](./img/stack_8.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()**
    ![stack_9](./img/stack_9.png)    

### 스택 구현 예제
- 파이썬에서는 특별한 정의나 선언 없이 리스트에서 제공하는 method로 stack 자료구조를 활용 가능

- append(): 리스트의 가장 오른쪽 즉 인덱스 맨 마지막 다음 위치에 원소를 삽입
- pop(): 리스트의 가장 오른쪽 즉 마지막 인덱스에 원소를 반환 후 리스트에서 반환했던 원소 삭제
- pop(), append() 모두 시간 복잡도가 $O(1)$로 상수 시간이다.
    ```
    stack = []

    # 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    stack.append(5)
    stack.append(2)
    stack.append(3)
    stack.append(7)
    stack.pop()
    stack.append(1)
    stack.append(4)
    stack.pop()

    # stack의 최상단 원소부터 출력
    # 리스트로 따지자면 인덱스 -1부터 끝까지 step을 -1로 갖고 출력
    print(stack[::-1]) 
    print(stack) # 최하단 원소부터 출력
    ```
    ```
    [1,3,2,5]
    [5,2,3,1]
    ```
## 큐(queue) 자료구조
- 먼저 들어 온 데이터가 먼저 나가는 형싱의 자료구조이다.(**선입선출**)

- 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있다.

- **즉 큐는 tail(뒤)에서 데이터를 넣고 front(앞)에서 데이터를 빼는 구조이다.**
![queue_1](./img/queue_1.png)

### 큐 동작 예시
- 데이터를 tail에 넣고 뺄 때는 front에서 뺀다.
- **삽입(5)** - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![queue_2](./img/queue_2.png)

- **삽입(5) - 삽입(2)** - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![queue_3](./img/queue_3.png)

- **삽입(5) - 삽입(2) - 삽입(3)** - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![queue_4](./img/queue_4.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7)** - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    ![queue_5](./img/queue_5.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제()** - 삽입(1) - 삽입(4) - 삭제()
    ![queue_6](./img/queue_6.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1)** - 삽입(4) - 삭제()
    ![queue_7](./img/queue_7.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4)** - 삭제()
    ![queue_8](./img/queue_8.png)

- **삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()**
    ![queue_9](./img/queue_9.png)

### 큐 구현 예제
- 파이썬에서는 deque 라이브러리를 활용해 큐 자료구조를 사용 가능

- deque는 stack + queue 자료구조로 tail과 front 양쪽에서 모두 데이터를 넣고 빼는 작업이 가능

- 리스트로 큐를 직접 구현하는 경우 시간 복잡도가 더 늘어남. 따라서 queue 구현은 꼭 deque를 활용해서 하라!

- deque에서 append()는 리스트의 append()와 동일하게 동작하며 가장 오른쪽에 값을 삽입

- deque에서 popleft()는 가장 왼쪽에 있는 데이터를 반환하고 삭제

    ```
    from collections import deque

    # 큐 자료구조를 사용하기 위해 deque 객체를 생성
    queue = deque()

    # 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
    queue.append(5)
    queue.append(2)
    queue.append(3)
    queue.append(7)
    queue.popleft()
    queue.append(1)
    queue.append(4)
    queue.popleft()

    print(queue)            # 먼저 들어온 순서대로 출력
    print(queue.reverse())  # 나중에 들어온 원소부터 출력 
    ```
    ```
    deque([3, 7, 1, 4])
    deque([4, 1, 7, 3])
    ```
- 위 그림에서는 왼쪽에서 값을 넣고 오른쪽에서 값을 빼지만 이를 반대로 왼쪽에서 값을 빼고 오른쪽에서 값을 넣는다고 해서 queue가 아닌 것이 아니다. 
  - 위 코드에서는 output_data <- [1,2,3,4] <- input_data의 형태로 동작하는 것이다.

## 재귀 함수
- 재귀 함수(Recursive Function)란 함수 내에서 자기 자신을 다시 호출하는 함수이다.

- 단순 형태의 재귀 함수 예제
    ```
    def recursive_function():
        print('재귀 함수를 호출합니다.')
        recursive_function()

    recursive_function()
    ```
  - '재귀 함수를 호출합니다.'라는 문자열을 무한히 출력한다.

  - while이나 for문과 같은 반복문 없이도 작업을 반복 가능하다.

  - 어느 정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력된다.

- 재귀 함수를 문제 출이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 한다.
- 종료 조건을 포함한 재귀 함수 예제
    ```
    def recursive_function(i):
        if i==100:
            return
        print(f'{i} 번째 재귀 함수에서 {i+1} 번째 재귀 함수를 호출합니다.')
        recursive_function(i+1)
        print(f'{i} 번째 재귀 함수를 종료합니다.')

    recursive_function(1)
    ```
    - i = 1에 해당하는 '{i} 번째 재귀 함수에서 {i+1} 번째 재귀 함수를 호출합니다.'를 출력해 i = 99에 해당하는 '{i} 번째 재귀 함수에서 {i+1} 번째 재귀 함수를 호출합니다.'를 출력하고 i = 99에 해당하는 '{i} 번째 재귀 함수를 종료합니다.'부터 i = 1에 해당하는 '{i} 번째 재귀 함수를 종료합니다.'까지 출력한다.
    
    - 이처럼 재귀 함수를 이용하면 마치 스택에 데이터를 넣었다가 꺼내는 것처럼 실제로 각각의 함수에 대한 정보가 스택 frame에 담기게 되어서 가장 마지막에 호출된 함수부터 차례로 종료된다.
### 재귀 함수 구현 예제: 팩토리얼 구현
- $n! = 1 \times 2 \times 3 \times \cdots \times (n-1) \times n$이고 $0! = 1! = 1$이다.
    ```
    # 반복문을 통해 구현한 n!
    def factorial_iterative():
        result = 1
        for i in range(1,n+1):                  # 1부터 n까지의 수를 차례대로 곱함
            result *= i
        return result

    # 재귀 함수를 이용해 구현한 n!
    def factorial_recursive(n):
        if n<=1:                                # n이 1 이하인 경우 1을 반환
            return 1
        return n * factorial_recursive(n-1)     # n! = n * (n-1)!를 그대로 적용

    # 5! 결과 출력
    print('반복적으로 구현: ', factorial_iterative(5))
    print('재귀적으로 구현: ', factorial_recursive(5))
    ```
### 재귀 함수 구현 예제: 최대공약수 계산(유클리드 호제법)
- 두 개의 자연수에 대한 최대공약수를 구하는 대표적인 알고리즘으로는 유클리드 호제법이 있다.

- 유클리드 호제법
  - 두 자연수 A, B에 대하여 (A>B) A를 B로 나눈 나머지를 R이라고 한다.
  - 이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같다.
- 유클리드 호제법의 아이디어를 그대로 재귀 함수로 작성할 수 있다.
  - 예시: $GCD(192,162) = GCD(12,6) -> 6$
    ![Recursive_Function_1](./img/Recursive_Function_1.png)
    ```
    def gcd(a, b):
        if a%b==0:
            return b
        else:
            return gcd(b, a%b)

    print(gcd(192,162))
    ```
    ```
    6
    ```
### 재귀 함수 사용의 유의 사항
- 재귀 함수를 잘 활용하면 복접한 알고리즘을 간결하게 작성 가능하다.
  - 단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있으며 이 부분을 명심해야 한다.

- ***모든 재귀 함수는 반복문을 이용하여 동일한 기능을 구현할 수 있다.***

- 재귀함수가 반복문보다 항상 유리한 것은 아니다.

- 컴퓨터가 함수를 연속적으로 호출하면 메모리 내부 stack에 호출한 함수가 끝날 때까지 계속 쌓인다.
  - **그래서 스택을 사용해야 할 때 구현상 스택 라이브러리 대신 재귀함수를 활용하는 경우가 많다.**

  - 대표적으로 DFS를 더욱 간결하고 짧은 코드로 작성하기 위해 재귀 함수를 이용해 DFS를 구현하기도 한다.
