# 바이너리 인덱스 트리
## 데이터 업데이트가 가능한 상황에서의 구간 합 문제
- 어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려고 한다. 만약에 1, 2, 3, 4, 5라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.
- 데이터 개수: N(0 < N < 1,000,000)
- 데이터 변경 횟수: M(0 < M < 10,000)
- 구간 합 계싼 횟수: K(1 < K < 10,000)

- 단순히 선형적으로 값을 찾고 구간합을 구한다면 $O(NK)$가 될 것이고 이를 줄이기 위해 사용하는 것이 BIT이다.

### BIT(Binary Indexed Tree)
- **바이너리 인덱스 트리**(**binary indexed tree**)는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조를 말한다.
  - **펜윅 트리**(**fenwick tree**)라고도 한다.

- 구간합은 합 배열을 통해 값을 미리 계산해서 빠르게 구할 수 있다. 그러나 합 배열은 업데이트가 굉장히 느리다.
  - 즉 구간 합을 구하는 문제에서 데이터의 업데이트가 자주 발생하면 합 배열이 성능 측면에서 굉장히 안좋아지고 시간 복잡도가 증가한다.
  - 그래서 인덱스 트리가 사용되는 거다.

#### 사전 지식
- 정수에 따른 2진수 표기
    |정수|2진수 표기|
    |----|------------|
    |7|00000000 00000000 00000000 0000111|
    |-7|11111111 11111111 11111111 1111001|

- 0이 아닌 마지막 비트를 찾는 방법
  - 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서 **K & -K**를 계산하면 된다.
    |정수|2진수 표기|K & -K|
    |----|---------|---|
    |0|00000000 00000000 00000000 0000000|0|
    |1|00000000 00000000 00000000 0000001|1|
    |2|00000000 00000000 00000000 0000010|2|
    |3|00000000 00000000 00000000 0000011|1|
    |4|00000000 00000000 00000000 0000100|4|
    |5|00000000 00000000 00000000 0000101|1|
    |6|00000000 00000000 00000000 0000110|2|
    |7|00000000 00000000 00000000 0000111|1|
    |8|00000000 00000000 00000000 0001000|8|

#### 기본 구조
- 구간합을 구해야 하는 원본 배열 arr이 있고, index 1부터 n까지 데이터가 저장되어 있다고 하자.
- 트리를 저장하기 위해 배역 tree를 선언하고 이때 tree 배열은 인덱스 1부터 n까지 사용할 것이므로 사이즈는 n+1이 된다. 

    ![BIT-2](./img/BIT-2.png)

- 위 이미지에서 빨간색 숫자는 tree의 인덱스이고 각 네모 박스의 구간은 해당 인덱스가 담고있는 구간의 합이다. 이때 구간의 오른쪽 끝은 tree의 인덱스와 같다.
  - 예를 들어 tree[8] = arr[1] + arr[2] + ... + arr[8]이고 tree[10] = arr[9] + arr[10]이다.

#### 트리 인덱스와 구간의 관계
- tree[12]는 인덱스 12, 구간 [9, 12]이다. 12를 비트로 보면 00000000 00000000 00000000 0001100 이고 K & -K 연산을 하면 4이다. 이는 인덱스 k노드(tree[k])가 담고있는 구간의 총 길이이다. 

- 다시 말해 인덱스 값을 K & -K 연산하면 해당 인덱스가 담고있는 구간의 총 길이가 나온다.

- tree[n]은 arr의 뒤쪽 (n&-n)개 원소 합을 저장한다.

#### 부분 합 구하기: 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산
- arr[1] + arr[2] + ... + arr[7]을 구한다고 가정하자. 아래 노란색으로 색칠된 원소 값을 더하면 된다.

    ![BIT-3](./img/BIT-3.png)

- tree[7] + tree[6] + tree[4]를 구해야 한다. 즉 tree[7] + tree[7 - (7&-7) = 6] + tree[6-(6&-6)=4]인 것이다.
- 부분합을 계산할 때 구하고 싶은 prefix의 끝 인덱스를 k라고 하면, k에서 (k & -k)를 반복해서 빼며 k가 담당하는 구간들을 순서대로 더한다.
- 즉 `k -= (k & -k)`를 통해 다음에 더할 tree 원소의 인덱스를 구한다.

#### 업데이트: 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경
- arr[3]에 k를 더해서 업데이트 했다고 하자. arr[3]이 바뀌면서 영향을 받는 tree 원소는 아래 색칠한 것과 같다.(즉 구간 내에 3이 포함되어 있는 원소를 업데이트 해야한다.)

    ![BIT-4](./img/BIT-4.png)

- 3, 4, 8, 16이 어떤 관계에 있는지 보면 4 = 3 + (3&-3), 8 = 4 + (4&-4), 16 = 8 + (8&-8)이다.
- 업데이트 시에는 현재 인덱스 k에 대해 `k += (k & -k)`를 반복하며 k를 포함하는 모든 상위 구간을 갱신한다.

- 데이터의 개수가 N개일 때 높이는 $O(logN)$ 으로 형성된다. 
- 즉 prefix sum 조회도, update도 tree 배열에서 접근하는 횟수가 최대 $O(logN)$
- 따라서 합 배열이 업데이트가 발생했을 때 모든 배열의 원소를 업데이트 해야하는 것과 달리 BIT는 $O(logN)$의 시간 복잡도로 필요한 tree 원소만 업데이트 하면 된다.

### BIT 구현
```
import sys
input = sys.stdin.readline

# 데이터의 개수(n), 뱐경 횟수(m), 구간 합 계산 횟수(k)
n, m, k = map(int, input().split())

# 전체 데이터의 개수는 최대 1,000,000개
arr = [0] * (n+1)
tree = [0] * (n+1)

# i번쩨 수까지의 누적 합을 계산하는 함수
def prefix_sum(i):
    result = 0
    while i>0:
        result += tree[i]
        # 0이 아닌 마지막 비트만큼 빼가면서 이동
         i -= (i&-i)
    return result

# i번재 수를 dif만큼 더하는 함수
def update(i, dif):
    while i <= n:
        tree[i] += dif
        i += (i&-i)

# start부터 end까지의 구간 합을 계산하는 함수
def interval_sum(start,end):
    return prefix_sum(end) - prefix_sum(start-1)

for i in range(1, n+1):
    x = int(input())
    arr[i] = x
    update(i,x)

for i in range(m+k):
    a, b, c = map(int, input().split())
    # a가 1인 경우 업데이트 연산
    if a == 1:
        arr[b] = c # 인덱스 b인 원소를 값 c로 업데이트
        update(b, c - arr[b]) 
    else:
        print(interval_sum(b,c)) # 인덱스 b에서 c까지 구간 합 계산
```